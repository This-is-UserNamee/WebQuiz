## gameData 内の各変数の遷移について

このドキュメントは、WebQuizアプリケーションにおけるゲームデータ (`gameData`) 内の各変数が、ゲームの状態遷移に伴ってどのように変化するかを詳細に記述します。

### gameData の構造

```typescript
interface GameData {
  questions: Question[]; // 問題オブジェクトの配列
  currentQuestionIndex: number; // 現在の問題のインデックス
  questionState: 'idle' | 'presenting' | 'reading' | 'timer_running' | 'paused' | 'answering' | 'result'; // 1問ごとの状態
  prePauseState: 'reading' | 'timer_running' | null; // 中断前の状態 (読み上げ中 or タイマー作動中)
  timerReadyPlayerIds: string[]; // タイマー開始準備完了者リスト (questionReadyイベントを送信したプレイヤーIDの配列)
  answeredPlayerIds: string[]; // その問題で既に回答権を失ったプレイヤーIDの配列
  activeAnswer: { playerId: string; currentAnswerIndex: number; } | null; // 現在の回答権を持つプレイヤー情報
  timeoutId: NodeJS.Timeout | null; // setTimeoutのID (サーバーサイドのみ)
  timerStartTime: number; // タイマー開始時刻 (Date.now()) (サーバーサイドのみ)
  remainingTime: number; // タイマーの残り時間 (ミリ秒) (サーバーサイドのみ)
}
```

### 各状態遷移に伴う gameData 内の変数の変化

#### 1. ルーム作成時 (`createRoom` イベント)

*   **`questions`**: 空の配列 `[]` で初期化されます。ゲーム開始時にシャッフルされた問題が設定されます。
*   **`currentQuestionIndex`**: `0` で初期化されます。
*   **`questionState`**: `'idle'` で初期化されます。
*   **`prePauseState`**: `null` で初期化されます。
*   **`timerReadyPlayerIds`**: 空の配列 `[]` で初期化されます。
*   **`answeredPlayerIds`**: 空の配列 `[]` で初期化されます。
*   **`activeAnswer`**: `null` で初期化されます。
*   **`timeoutId`**: `null` で初期化されます。
*   **`timerStartTime`**: `0` で初期化されます。
*   **`remainingTime`**: `0` で初期化されます。

#### 2. ゲーム開始時 (`startGame` イベント)

*   **`questions`**: サーバーにロードされた全問題がシャッフルされ、この配列に設定されます。
*   **`currentQuestionIndex`**: `0` にリセットされます（もしゲームが再開される場合）。
*   **`questionState`**: `'presenting'` に設定されます。
*   **`prePauseState`**: `null` に設定されます。
*   **`timerReadyPlayerIds`**: 空の配列 `[]` にリセットされます。
*   **`answeredPlayerIds`**: 空の配列 `[]` にリセットされます。
*   **`activeAnswer`**: `null` にリセットされます。
*   **`timeoutId`**: `null` にリセットされます。
*   **`timerStartTime`**: `0` にリセットされます。
*   **`remainingTime`**: `0` にリセットされます。

#### 3. 新しい問題のライフサイクル開始時 (サーバーの `startQuestionLifecycle` 関数)

これは、ゲーム開始時、または前の問題が終了して次の問題へ移行する際に呼び出されます。

*   **`currentQuestionIndex`**: 次の問題へ進むため、インクリメントされます。
*   **`questionState`**: `'presenting'` に設定されます。
*   **`prePauseState`**: `null` にリセットされます。
*   **`timerReadyPlayerIds`**: 空の配列 `[]` にリセットされます。
*   **`answeredPlayerIds`**: 空の配列 `[]` にリセットされます。
*   **`activeAnswer`**: `null` にリセットされます。
*   **`timeoutId`**: 既存のタイマーがあれば `clearTimeout` でクリアされ、`null` に設定されます。
*   **`timerStartTime`**: `0` にリセットされます。
*   **`remainingTime`**: `0` にリセットされます。
*   **フロントエンド側**: `newQuestion` イベントを受信し、表示中の問題文 (`displayedQuestionText`) と読み上げ進行度 (`readingIndex`) をリセットします。

#### 4. 問題提示 (`presenting` 状態)

*   **`questionState`**: `'presenting'` のままです。
*   他の `gameData` 変数はこの状態では直接変化しません。
*   **フロントエンド側**: 問題文は表示されず、「次の問題が始まります...」のような準備中のUIが表示されます。

#### 5. 読み上げ開始 (`readingStarted` イベント)

*   **`questionState`**: `'reading'` に設定されます。
*   他の `gameData` 変数はこの状態では直接変化しません。
*   **フロントエンド側**: `questionState` が `'reading'` になったことを検知し、`currentQuestion.text` を一文字ずつ `displayedQuestionText` に追加していくアニメーションを開始します。

#### 6. 問題読み上げ完了 (フロントエンドで読み上げアニメーションが完了)

*   **フロントエンド側**: `currentQuestion.text` の全文字が `displayedQuestionText` に表示され終わると、フロントエンドは自動的に `socket.emit('timerReady', { roomId: room.id })` をサーバーに送信します。

#### 7. タイマー開始 (`timerStarted` イベント)

*   **`timerReadyPlayerIds`**: 全クライアントから `timerReady` イベントを受信すると、サーバーは `timerReadyPlayerIds` をクリアし、次の状態へ遷移します。
*   **`questionState`**: `'timer_running'` に設定されます。
*   **`timerStartTime`**: タイマーが開始された時点の `Date.now()` が設定されます。
*   **`remainingTime`**: 初期タイマー時間（例: 10000ミリ秒）が設定されます。
*   **`timeoutId`**: 新しい `setTimeout` のIDが設定されます。
*   **フロントエンド側**: `timerStarted` イベントを受信し、見た目用のタイマー表示を開始します。

#### 8. 早押し (`buzz` イベント)

*   **`prePauseState`**: 現在の `questionState` (`reading` または `timer_running`) が保存されます。
*   **`questionState`**: `'answering'` に設定されます。
*   **`activeAnswer`**: 早押ししたプレイヤーの `playerId` と `currentAnswerIndex` (`0` で初期化) を持つオブジェクトが生成され、設定されます。
*   **`timeoutId`**: もしタイマーが作動中であれば、`clearTimeout` でクリアされ、`null` に設定されます。
*   **`remainingTime`**: もしタイマーが作動中であれば、一時停止時点での残り時間が計算され、更新されます。
*   **フロントエンド側**:
    *   `questionState` が `'reading'` から `'answering'` に変わったことを検知し、**読み上げアニメーションを停止します**（`setInterval` がクリアされるため）。
    *   `questionState` が `'timer_running'` から `'answering'` に変わったことを検知し、**タイマー表示を一時停止します**。

#### 9. 回答提出 (`submitCharacter` イベント)

*   **`activeAnswer.currentAnswerIndex`**: 正解の場合、インクリメントされます。
*   **`activeAnswer`**: 完答または不正解の場合、`null` に設定されます。
*   **`answeredPlayerIds`**: 不正解の場合、回答権を失ったプレイヤーの `socket.id` が追加されます。
*   **`questionState`**:
    *   完答した場合、`result` に設定されます。
    *   不正解で、まだ回答権を持つプレイヤーがいる場合、`prePauseState` に基づいて `'reading'` または `'timer_running'` に復帰します。
    *   不正解で、全員が回答権を失った場合、`result` に設定されます。
*   **`prePauseState`**: 不正解で復帰する場合、`null` にリセットされます。
*   **`timeoutId`**: 不正解でタイマーが再開する場合、新しい `setTimeout` のIDが設定されます。
*   **`timerStartTime`**: 不正解でタイマーが再開する場合、`Date.now()` が設定されます。
*   **フロントエンド側**:
    *   `questionState` が `'answering'` から `'reading'` に復帰した場合、`readingIndex` を維持したまま**読み上げアニメーションを再開します**。
    *   `questionState` が `'answering'` から `'timer_running'` に復帰した場合、`remainingTime` を使用して**タイマー表示を再開します**。

#### 10. 時間切れ (タイマーが0になった場合)

*   **`questionState`**: `'result'` に設定されます。
*   **`activeAnswer`**: `null` に設定されます。
*   **`currentQuestionIndex`**: インクリメントされます。
*   **`timeoutId`**: `null` に設定されます。

#### 11. 問題結果表示 (`result` 状態)

*   **`questionState`**: `'result'` のままです。
*   **`activeAnswer`**: `null` であることが保証されます。
*   他の `gameData` 変数はこの状態では直接変化しません。

#### 12. ゲーム終了時 (`gameFinished` イベント)

*   **`questionState`**: `'idle'` にリセットされます。
*   **`currentQuestionIndex`**: `0` にリセットされます。
*   **`questions`**: そのまま保持されます。
*   **`timerReadyPlayerIds`**: 空の配列 `[]` にリセットされます。
*   **`answeredPlayerIds`**: 空の配列 `[]` にリセットされます。
*   **`activeAnswer`**: `null` にリセットされます。
*   **`timeoutId`**: `null` にリセットされます。
*   **`timerStartTime`**: `0` にリセットされます。
*   **`remainingTime`**: `0` にリセットされます。
*   **フロントエンド側**: `displayedQuestionText` と `readingIndex` もリセットされます。
